/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers'
import type { FunctionFragment, Result } from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common'

export type SwapQueryStruct = {
  routerAdapter: PromiseOrValue<string>
  tokenOut: PromiseOrValue<string>
  minAmountOut: PromiseOrValue<BigNumberish>
  deadline: PromiseOrValue<BigNumberish>
  rawParams: PromiseOrValue<BytesLike>
}

export type SwapQueryStructOutput = [
  string,
  string,
  BigNumber,
  BigNumber,
  string
] & {
  routerAdapter: string
  tokenOut: string
  minAmountOut: BigNumber
  deadline: BigNumber
  rawParams: string
}

export type BridgeTokenStruct = {
  symbol: PromiseOrValue<string>
  token: PromiseOrValue<string>
}

export type BridgeTokenStructOutput = [string, string] & {
  symbol: string
  token: string
}

export type DestRequestStruct = {
  symbol: PromiseOrValue<string>
  amountIn: PromiseOrValue<BigNumberish>
}

export type DestRequestStructOutput = [string, BigNumber] & {
  symbol: string
  amountIn: BigNumber
}

export interface SynapseCCTPRouterInterface extends utils.Interface {
  functions: {
    'adapterSwap(address,address,uint256,address,bytes)': FunctionFragment
    'bridge(address,uint256,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))': FunctionFragment
    'calculateFeeAmount(address,uint256,bool)': FunctionFragment
    'feeStructures(address)': FunctionFragment
    'getConnectedBridgeTokens(address)': FunctionFragment
    'getDestinationAmountOut((string,uint256)[],address)': FunctionFragment
    'getOriginAmountOut(address,string[],uint256)': FunctionFragment
    'synapseCCTP()': FunctionFragment
  }

  getFunction(
    nameOrSignatureOrTopic:
      | 'adapterSwap'
      | 'bridge'
      | 'calculateFeeAmount'
      | 'feeStructures'
      | 'getConnectedBridgeTokens'
      | 'getDestinationAmountOut'
      | 'getOriginAmountOut'
      | 'synapseCCTP'
  ): FunctionFragment

  encodeFunctionData(
    functionFragment: 'adapterSwap',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'bridge',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      SwapQueryStruct,
      SwapQueryStruct
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'calculateFeeAmount',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'feeStructures',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'getConnectedBridgeTokens',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'getDestinationAmountOut',
    values: [DestRequestStruct[], PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'getOriginAmountOut',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'synapseCCTP',
    values?: undefined
  ): string

  decodeFunctionResult(functionFragment: 'adapterSwap', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'bridge', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'calculateFeeAmount',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'feeStructures',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getConnectedBridgeTokens',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getDestinationAmountOut',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getOriginAmountOut',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'synapseCCTP', data: BytesLike): Result

  events: {}
}

export interface SynapseCCTPRouter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  interface: SynapseCCTPRouterInterface

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>
  listeners(eventName?: string): Array<Listener>
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this
  removeAllListeners(eventName?: string): this
  off: OnEvent<this>
  on: OnEvent<this>
  once: OnEvent<this>
  removeListener: OnEvent<this>

  functions: {
    adapterSwap(
      recipient: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      amountIn: PromiseOrValue<BigNumberish>,
      tokenOut: PromiseOrValue<string>,
      rawParams: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    bridge(
      recipient: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    calculateFeeAmount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      isSwap: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { fee: BigNumber }>

    feeStructures(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber] & {
        relayerFee: number
        minBaseFee: BigNumber
        minSwapFee: BigNumber
        maxFee: BigNumber
      }
    >

    getConnectedBridgeTokens(
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BridgeTokenStructOutput[]] & { tokens: BridgeTokenStructOutput[] }
    >

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [SwapQueryStructOutput[]] & { destQueries: SwapQueryStructOutput[] }
    >

    getOriginAmountOut(
      tokenIn: PromiseOrValue<string>,
      tokenSymbols: PromiseOrValue<string>[],
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [SwapQueryStructOutput[]] & { originQueries: SwapQueryStructOutput[] }
    >

    synapseCCTP(overrides?: CallOverrides): Promise<[string]>
  }

  adapterSwap(
    recipient: PromiseOrValue<string>,
    tokenIn: PromiseOrValue<string>,
    amountIn: PromiseOrValue<BigNumberish>,
    tokenOut: PromiseOrValue<string>,
    rawParams: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  bridge(
    recipient: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    originQuery: SwapQueryStruct,
    destQuery: SwapQueryStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  calculateFeeAmount(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    isSwap: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  feeStructures(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber] & {
      relayerFee: number
      minBaseFee: BigNumber
      minSwapFee: BigNumber
      maxFee: BigNumber
    }
  >

  getConnectedBridgeTokens(
    tokenOut: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BridgeTokenStructOutput[]>

  getDestinationAmountOut(
    requests: DestRequestStruct[],
    tokenOut: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<SwapQueryStructOutput[]>

  getOriginAmountOut(
    tokenIn: PromiseOrValue<string>,
    tokenSymbols: PromiseOrValue<string>[],
    amountIn: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<SwapQueryStructOutput[]>

  synapseCCTP(overrides?: CallOverrides): Promise<string>

  callStatic: {
    adapterSwap(
      recipient: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      amountIn: PromiseOrValue<BigNumberish>,
      tokenOut: PromiseOrValue<string>,
      rawParams: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    bridge(
      recipient: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: CallOverrides
    ): Promise<void>

    calculateFeeAmount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      isSwap: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    feeStructures(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber] & {
        relayerFee: number
        minBaseFee: BigNumber
        minSwapFee: BigNumber
        maxFee: BigNumber
      }
    >

    getConnectedBridgeTokens(
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BridgeTokenStructOutput[]>

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<SwapQueryStructOutput[]>

    getOriginAmountOut(
      tokenIn: PromiseOrValue<string>,
      tokenSymbols: PromiseOrValue<string>[],
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<SwapQueryStructOutput[]>

    synapseCCTP(overrides?: CallOverrides): Promise<string>
  }

  filters: {}

  estimateGas: {
    adapterSwap(
      recipient: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      amountIn: PromiseOrValue<BigNumberish>,
      tokenOut: PromiseOrValue<string>,
      rawParams: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    bridge(
      recipient: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    calculateFeeAmount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      isSwap: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    feeStructures(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getConnectedBridgeTokens(
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getOriginAmountOut(
      tokenIn: PromiseOrValue<string>,
      tokenSymbols: PromiseOrValue<string>[],
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    synapseCCTP(overrides?: CallOverrides): Promise<BigNumber>
  }

  populateTransaction: {
    adapterSwap(
      recipient: PromiseOrValue<string>,
      tokenIn: PromiseOrValue<string>,
      amountIn: PromiseOrValue<BigNumberish>,
      tokenOut: PromiseOrValue<string>,
      rawParams: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    bridge(
      recipient: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    calculateFeeAmount(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      isSwap: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    feeStructures(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getConnectedBridgeTokens(
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getOriginAmountOut(
      tokenIn: PromiseOrValue<string>,
      tokenSymbols: PromiseOrValue<string>[],
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    synapseCCTP(overrides?: CallOverrides): Promise<PopulatedTransaction>
  }
}
